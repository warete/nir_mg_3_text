\chapter{Разработка пользовательского интерфейса для нейронной сети}
В рамках данной работы нужно было разработать приложение, предоставляющее пользовательский интерфейс для работы с задачами машинного обучения. Необходимо, чтобы была возможность загрузить файл с выборкой, настроить параметры модели, запустить процесс обучения и отобразить результаты в виде статистических метрик.


Для определения того, что может сделать пользователь и что он увидит в результате, была разработана диаграмма деятельности (рисунок~\ref{fig:deyatel-diagram1}). Данная диаграмма будет полезной как при разработке, так и при тестировании, т.к. содержит последовательную схему действий пользователя.


\imgh{0.7}{deyatel-diagram1}{Диаграмма деятельности для программы}


В большинстве популярных библиотек с реализацией алгоритмов машинного обучения и нейросетей описанных ранее для обучения модели используется метод с названием fit, принимающий данные тренировочной выборки, а для запуска алгоритма для тестовой выборки метод с названием predict, принимающий данные тестовой выборки. Исходя из этого, было принято решение разрабатывать приложение в рамках данной работы в виде библиотеки, которую можно будет подключить к любой модели машинного обучения, имеющей перечисленные выше методы.


\section{Архитектура приложения}
Перед началом разработки приложения необходимо определить, с помощью каких технологий оно будет реализовано. Если в самом начале выбрать неправильную архитектуру и инструменты для разработки, то в дальнейшем это может сильно усложнить поддержку программного обеспечения.


Описанные в предыдущей главе существующие решения MachineLearningGUI и Weka представлены в виде десктопных приложений. Когда данных для анализа много, такой подход может сильно усложнить работу, т.к. для обучения модели зачастую может потребоваться очень много времени и ресурсов. Поэтому для разрабатываемого приложения была выбрана клиент-серверная архитектура. В качестве клиента будет web-приложение, общающееся с сервером посредством REST-API. За счет использования такого подхода серверную часть с моделью можно будет вынести на отдельный сервер и производить расчеты именно там, не используя вычислительные ресурсы клиента. Также можно будет масштабировать данную систему, разместив ее в кластере. Еще одним плюсом выбора такой архитектуры является простота обновления программного обеспечения в будущем (при условии, что оно будет располагаться не локально, а с доступом через интернет).


Исходя из информации про общий принцип работы моделей в большинства библиотек и выбранной архитектуры для лучшего понимания устройства всей схемы работы приложения были выделены компоненты и интерфейсы разрабатываемой системы, а также построена диаграмма компонентов (рисунок~\ref{fig:component_diagram}).


\imgh{1}{component_diagram}{Диаграмма компонентов разрабатываемой системы}


Схема взаимодействия клиента, сервера и нейросетевой модели представлено на диаграмме последовательности (рисунок~\ref{fig:sequence-diagram1}). Для взаимодействия клиента и сервера был выбран протокол HTTP из-за большой поддержки во многих языках программирования, библиотеках и фреймворках.


\imgh{1}{sequence-diagram1}{Диаграмма последовательности для разрабатываемого приложения}


В качестве языка программирования был выбран Python, т.к. большинство популярных библиотек для машинного обучения написаны именно на нем и нужно будет с ними взаимодействовать. В силу простоты реализации и возможности быстрого прототипирования RESP-API интерфейса для backend-части был выбран веб-фреймворк Flask. Flask имеет множество дополнительных библиотек для расширения функционала, а также подробную документацию.


Для разработки современного и быстро работающего без перезагрузки страницы интерфейса был выбран язык программирования JavaScript и фреймворк VueJS. Приложение на VueJS состоит из отдельных компонентов, каждый из которых имеет свое состояние и свойства. Такой подход позволяет переиспользовать компоненты и удобно настраиваться взаимодействие между ними, сохраняя возможность масштабирования при командной разработке.

\section{Разработка frontend-части}

Для разработки frontend-части приложения была взята библиотека VueJS-компонентов Vuetify, содержащая в себе большое количество готовых компонентов в Material-дизайне. Т.к. процесс работы с приложением можно разбить на шаги, то были разработаны отдельные компоненты для каждого шага. Пользователь может перемещаться между шагами с помощью кнопок “Вперед” и “Назад”, которые будут активны, если на текущем шаге все поля были заполнены верно (при их наличии).


На первом шаге пользователь может загрузить файл с обучающей выборкой (рисунок~\ref{fig:prog_skr_1}). Пока что поддерживаются только CSV-файлы.


\imgh{1}{prog_skr_1}{Скриншот разрабатываемого приложения на шаге “Загрузка данных”}


На втором шаге происходит выбор значений параметров модели. По умолчанию всегда выводится параметр “Процент тестовой выборки”, который отвечает за то, сколько процентов от общей выборки будет использоваться для тестирования. Набор параметров, которые выводятся на данном шаге определяется пользователем, при подключении данного приложения к своей модели. Интерфейс шага “Настройка параметров модели” представлен на рисунке~\ref{fig:prog_skr_2}.


\imgh{1}{prog_skr_2}{Скриншот разрабатываемого приложения на шаге “Настройка параметров модели”}


После нажатия пользователем кнопки “Вперед” происходит отправка запроса на сервер со значениями параметров и выбранным файлом и запускается процесс обучения и определения классов для тестовой выборки.


На шаге “Результаты” после успешного выполнения пользователь увидит рассчитанные значения точности, чувствительности и специфичности (рисунок~\ref{fig:prog_skr_3}). Если пользователя не устроили получившиеся результаты, то он может вернуться на предыдущий шаг и изменить параметры модели.


\imgh{1}{prog_skr_3}{Скриншот разрабатываемого приложения на шаге “Результаты”}


Frontend-приложение получает и отправляет данные серверу посылая AJAX-запросы к API-методам сервера, т.е. без перезагрузки страницы. Для каждого запроса сервер возвращает статус ответа и данные. При возникновении ошибок выводятся сообщения в консоль браузера.

\section{Разработка REST API-сервиса}

Backend-часть представляет собой веб-приложение на Flask. Приложение состоит из одного файла, в котором находится класс Application, который принимает на вход нейросетевую модель, путь к папке для загрузки файлов выборки, разделитель, который используется в CSV-файле, список с описанием параметров модели и порт, на котором будет запущено приложение. В одном из методов класса содержится описание и код для всех маршрутов приложения. В рамках данной работы были реализованы следующие маршруты:
\begin{itemize}
	\item[-] / - главная страница приложения, с которой работает пользователь;
	\item[-] /model\_params - API-метод для получения списка параметров модели;
	\item[-] /upload\_data - API-метод для загрузки CSV-файла с обучающей выборкой;
	\item[-] /fit\_predict - API-метод для запуска процесса обучения и классификации тестовой выборки.
\end{itemize}



Все API-методы возвращают ответ в формате JSON. Пример ответа метода /fit\_predict представлен на рисунке~\ref{fig:fir_preduct_response}.


\imgh{0.7}{fir_preduct_response}{Пример ответа метода /fit\_predict в формате JSON}


При обработке запроса метода /fit\_predict происходит проверка наличия у объекта модели необходимых для работы методов с названиями fit и predict. Если они отсутствуют, то вернется ответ с ошибкой. После этого происходит проверка на существование файла с данными, т.к. за время заполнения пользователем параметров модели на втором шаге с файлом могло что-то произойти. 


Затем данные из файла разделяются на два набора данных - обучающую и тестовую выборки. Для этой операции была использована функция train\_test\_split из библиотеки Scikit-learn. Во время ее вызова ей необходимо передать  массив данных, размер тестовой выборки в процентном соотношении и флаг необходимости перемешивания данных. 


Значения параметров модели, указанные пользователем на втором шаге передаются внутрь модели и после этого последовательно вызываются методы fit и predict. Далее по полученным данным происходит расчет точности классификации, чувствительности и специфичности в процентах.


Для запуска самого приложения нужно создать объект класса Application, передав в него все необходимые параметры, а затем вызвать метод run. По умолчанию приложение будет доступно по адресу http://127.0.0.1:5000.

\section{Сборка в pip-пакет}

Для возможности использования разработанного приложения в других проектах было принято решение оформить его в виде pip-пакета - популярного формата модулей в языке Python.


Для сборки такого пакета необходимо создать файл setup.py и использовать в нем функцию setup из библиотеки setuptools. Данная функция принимает следующие параметры:
\begin{itemize}
	\item[-] Название пакета;
	\item[-] Версию пакета;
	\item[-] Путь до модуля, который будет использоваться в качестве пакета;
	\item[-] Описание;
	\item[-] Файлы, которые должны попасть в сборку.
\end{itemize}


Так как разработанное приложение включает в себя отдельное frontend-приложение на VueJS, то последним параметром необходимо передать путь до папки с ним.


После этого с помощью команды python setup.py sdist будет создан tar.gz-архив с пакетом.